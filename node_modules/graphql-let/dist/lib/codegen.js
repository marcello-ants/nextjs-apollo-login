"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@graphql-codegen/core");
const fs_1 = require("fs");
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const gen_dts_1 = __importDefault(require("./gen-dts"));
const print_1 = require("./print");
const fs_2 = require("fs");
const { readFile, writeFile } = fs_1.promises;
const mkdirp = util_1.promisify(mkdirp_1.default);
// For the loader can process a same file simultaneously
const processingTasks = new Map();
function wrapAsModule(fileName, content) {
    return `declare module '*/${fileName}' {
  ${content.replace(/\n/g, '\n  ')}}`;
}
async function processGraphQLCodegen(codegenOpts, tsxFullPath, gqlFullPath, gqlContent) {
    const tsxContent = await core_1.codegen({
        ...codegenOpts,
        filename: tsxFullPath,
        documents: [
            {
                filePath: gqlFullPath,
                content: graphql_tag_1.default(gqlContent),
            },
        ],
    });
    await mkdirp(path_1.default.dirname(tsxFullPath));
    await writeFile(tsxFullPath, tsxContent);
    return tsxContent;
}
async function processGenDts(dtsFullPath, tsxFullPath, gqlFullPath, dtsRelPath) {
    await mkdirp(path_1.default.dirname(dtsFullPath));
    const dtsContent = await gen_dts_1.default(tsxFullPath);
    if (!dtsContent)
        throw new Error(`Generate ${dtsFullPath} fails.`);
    await writeFile(dtsFullPath, wrapAsModule(path_1.default.basename(gqlFullPath), dtsContent));
    print_1.printInfo(`${dtsRelPath} was generated.`);
    return dtsContent;
}
async function codegen(gqlContent, gqlFullPath, tsxFullPath, dtsRelPath, dtsFullPath, options, codegenOpts) {
    let tsxContent;
    if (fs_2.existsSync(tsxFullPath)) {
        tsxContent = await readFile(tsxFullPath, 'utf-8');
    }
    else if (processingTasks.has(tsxFullPath)) {
        tsxContent = await processingTasks.get(tsxFullPath);
    }
    else {
        const tsxPromise = processGraphQLCodegen(codegenOpts, tsxFullPath, gqlFullPath, gqlContent);
        processingTasks.set(tsxFullPath, tsxPromise);
        tsxContent = await tsxPromise;
        processingTasks.delete(tsxFullPath);
    }
    if (fs_2.existsSync(dtsFullPath) || processingTasks.has(dtsFullPath)) {
        // Already exists or is processing. Just skip.
    }
    else {
        const dtsPromise = processGenDts(dtsFullPath, tsxFullPath, gqlFullPath, dtsRelPath);
        processingTasks.set(dtsFullPath, dtsPromise);
        await dtsPromise;
        processingTasks.delete(dtsFullPath);
    }
    return tsxContent;
}
exports.codegen = codegen;
