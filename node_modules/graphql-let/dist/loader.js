"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const yaml_1 = require("yaml");
const hash_1 = __importDefault(require("./hash"));
const create_codegen_opts_1 = __importDefault(require("./lib/create-codegen-opts"));
const paths_1 = require("./lib/paths");
const codegen_1 = require("./lib/codegen");
const consts_1 = require("./lib/consts");
const { readFile } = fs_1.promises;
const graphlqCodegenLoader = function (gqlContent) {
    const callback = this.async();
    (async () => {
        const { resourcePath: gqlFullPath, rootContext: userDir } = this;
        const configPath = path_1.join(userDir, consts_1.DEFAULT_CONFIG_FILENAME);
        const config = yaml_1.parse(await readFile(configPath, 'utf-8'));
        const hash = hash_1.default(gqlContent);
        const { tsxFullPath, dtsFullPath, dtsRelPath } = paths_1.createPaths(userDir, config.generateDir, path_1.relative(userDir, gqlFullPath), hash);
        const codegenOpts = await create_codegen_opts_1.default(config, userDir);
        // Pretend .tsx for later loaders.
        // babel-loader at least doesn't respond the .graphql extension.
        this.resourcePath = `${gqlFullPath}.tsx`;
        try {
            const tsxContent = await codegen_1.codegen(gqlContent.toString(), gqlFullPath, tsxFullPath, dtsRelPath, dtsFullPath, config, codegenOpts);
            callback(undefined, tsxContent);
        }
        catch (e) {
            callback(e);
        }
    })();
};
exports.default = graphlqCodegenLoader;
